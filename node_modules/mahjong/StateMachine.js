"use strict";

var Timeout = require('herstimeout');

function State(ctx){
  this.ctx = ctx;
}

State.prototype.finish = function(){
  this.ctx.self.state = this.nextState();
  if(!this.ctx.self.state.ctx){
    console.trace();
    console.log(this.ctx.self.state);
    process.exit(0);
  }
  var nextstate = this.ctx.self.state;
  delete this.ctx;
  for(var i in this){
    delete this[i];
  }
  Timeout.set(function(ns){ns.go();},1,nextstate);
}

State.prototype.go = function(){
};

State.prototype.delayedInvoke = function(method,timeout){
  var args = [function _delayedInvoke(t,m,args){(t[m]).apply(t,args);},timeout,this,method,Array.prototype.slice.call(arguments,2)];
  Timeout.set.apply(Timeout,args);
};


/////////State Implementation

function MJState(ctx){
  State.call(this,ctx);
};

MJState.prototype = new State();
MJState.prototype.letPlayerIn = function(seat,statuscb,username,realmname){
  var data = this.ctx.data;
  var pfs = this.ctx.self.playerfunctionalities;
  var pf;
  for(var i=0; i<pfs.length; i++){
    var j = (i+seat)%pfs.length;
    var currName = pfs[j]._not_empty();
    for(var k=0; k<pfs.length; k++){
      if(pfs[k]._not_empty() === username){
        statuscb('PLAYER_IN_ROOM');
        console.log(username,'cannot enter the room because he already did');
        return;
      }
    }
    if(!currName){
      pf = pfs[j];
      break;
    }
  }
  if(!pf){
    statuscb('ROOMFULL');//if no seat found
    return;
  }
  pf._start(username,realmname);
  console.log('JJ',j,'username',username);
  statuscb('OK');//if ok
};

MJState.prototype.playerBuysIn = function(amount,statuscb,username,realmname){
  var data = this.ctx.data;
  var pfs = this.ctx.self.playerfunctionalities;
  var pf;
  for(var i=0;i<pfs.length;i++){
    if(pfs[i]._not_empty()===username){
      pf=pfs[i];
    }
  }
  if(!pf){
    statuscb('NO_PLAYER');
    return;
  }
  var playercount = data.element(['playercount']).value();
  data.commit('increase_playercount',[
    ['set',['playercount'],[playercount+1]]
  ]);
  pf._doBuyIn(amount);
  statuscb('OK');
};

MJState.prototype.makeBet = function(amount,statuscb,username,realmname){
  return statuscb('INVALID_BET');
}

MJState.prototype.iWantToStay = function(statuscb,username,realmname){
  return statuscb('INVALID_FUNCTION_CALL');
}

MJState.prototype.playingPlayers = function(){
  var ret = [];
  var data = this.ctx.data;
  var pfs = this.ctx.self.playerfunctionalities;
  for(var i=0 ; i<pfs.length ; i++){
    if (pfs[i]._got_money()>0) ret.push({player:pfs[i],seat:i});
  }
  //traverse all the players and pick just those who have money to play or whatever...
  //... this.players
  return ret;
};

MJState.prototype.iWantOut = function(statuscb,username,realmname){
  var data = this.ctx.data;
  var pfs = this.ctx.self.playerfunctionalities;
  var pf;
  for(var i=0;i<pfs.length;i++){
    if(pfs[i]._not_empty()===username){
      pf=pfs[i];
    }
  }
  if(!pf){
    statuscb('NO_PLAYER');
    return;
  }
  var outflag = pf._get_outflag();
  console.log('Outflag is',outflag,'and we are gonna change it!');
  if(outflag==0){
    pf._activate_outflag();
    console.log('Outflag is ACTIVATED');
  }else{
    pf._disable_outflag();
    console.log('Outflag is DISABLED');
  }
  return statuscb('OK');
}

function IdleState(ctx){
  MJState.call(this,ctx);
};
IdleState.prototype = new MJState();
IdleState.prototype.go = function(){
  if (!this.ctx){
    return;
  }
  console.log('Lets take a breath..');
  console.log('Players can leave and enter now');
  var pfs = this.ctx.self.playerfunctionalities;
  this.delayedInvoke('checkAndFinish',1000);
}
IdleState.prototype.checkAndFinish = function(){
  var ps = this.playingPlayers();
  if (ps.length == 0){
    console.log('There are no players, we are stopping!');
    return;
  }
  console.log('Idle is out, there are',ps.length,'players ready to play');
  this.finish();
};
IdleState.prototype.constructor = IdleState;
IdleState.prototype.nextState = function(){
  return new WaitingState(this.ctx);
};
IdleState.prototype.playerBuysIn = function(amount,statuscb,username,realmname){
  var t = this;
  MJState.prototype.playerBuysIn.call(this,amount,function(errcode,errparams,errmessage){
    if(errcode==='OK'){
      t.go();
    }
    statuscb(errcode,errparams,errmessage);
  },username,realmname);
};

function WaitingState(ctx){
  MJState.call(this,ctx);
}

WaitingState.prototype = new MJState();

WaitingState.prototype.go = function(){
  this.ctx.data.commit('betting_timeout',[
    ['set',['waitingTimeout'],[120]]
  ]);
  var doTimeout = (function(_t){
    console.log('Waiting Timeout!');
    var t=_t,data=t.ctx.data,key=t.ctx.key;
    var worker = function(){
      var playerCount = data.element(['playercount']).value();
      if(playerCount == 0){
        data.commit('remove_timeout',[
          ['remove',['bettingTimeout']]
        ]);
        t.waitingStateHint = 'back';
        t.delayedInvoke('finish',2000);
        return;
      }
      if(playerCount == MAHJONGKAPACITY){
        data.commit('remove_timeout',[
          ['remove',['bettingTimeout']]
        ]);
        t.waitingStateHint = 'next';
        t.delayedInvoke('finish',2000);
        return;
      }
      var toval = data.element(['bettingTimeout']).value();
      console.log('TIME LEFT---',toval);
      if(toval){
        console.log('KUCAM DALJE');
        data.commit('timeout_changes',[
          ['set',['bettingTimeout'],[toval-1]]
        ]);
        Timeout.set(worker,1000);
      }else{
        data.commit('remove_timeout',[
          ['remove',['bettingTimeout']]
        ]);
        t.waitingStateHint = 'back';
        t.delayedInvoke('finish',2000);
        return;
      }
    };
    return worker;
  })(this);
  console.log('I SAD OPET');
  doTimeout();
}

WaitingState.prototype.nextState = function(){
  switch (this.waitingStateHint){
    case 'back':
      return new IdleState(this.ctx);
    case 'next':
      return new BettingState(this.ctx);
  }
}

WaitingState.prototype.iWantOut = function(statuscb,username,realmname){
  var data = this.ctx.data;
  var pfs = this.ctx.self.playerfunctionalities;
  var pf;
  for(var i=0;i<pfs.length;i++){
    if(pfs[i]._not_empty()===username){
      pf=pfs[i];
    }
  }
  if(!pf){
    statuscb('NO_PLAYER');
    return;
  }
  var playercount = data.element(['playercount']).value();
  data.commit('decrease_playercount',[
    ['set',['playercount'],[playercount-1]]
  ]);
  pf._iWantOut(username);
  statuscb('OK');
}

function BettingState(ctx){
  MJState.call(this,ctx);
}

BettingState.prototype = new MJState();
BettingState.prototype.go = function(){
  console.log('Betting time..');
  var pfs = this.ctx.self.playerfunctionalities;
  var ps = this.playingPlayers();
  this.ctx.playingPlayers = /* ?? this.ctx.validPlayers =*/ ps;
  for(var i=0; i<pfs.length;i++){
    pfs[i]._reset_my_bet();
  }
  this.ctx.data.commit('betting_timeout',[
    ['set',['bettingTimeout'],[10]],
    ['set',['betCount'],[0]],
    ['set',['roundCount'],[0]]
  ]);
  var doTimeout = (function(_t){
    console.log('Betting Timeout!');
    var t=_t,data=t.ctx.data,key=t.ctx.key;
    var worker = function(){
      var betCount = data.element(['betCount']).value();
      if(betCount == ps.length){
        data.commit('remove_timeout',[
          ['remove',['bettingTimeout']]
        ]);
        this.delayedInvoke('finish',1000);
        return;
      }
      var toval = data.element(['bettingTimeout']).value();
      console.log('TIME LEFT---',toval);
      if(toval){
        console.log('KUCAM DALJE');
        data.commit('timeout_changes',[
          ['set',['bettingTimeout'],[toval-1]]
        ]);
        Timeout.set(worker,1000);
      }else{
        data.commit('remove_timeout',[
          ['remove',['bettingTimeout']]
        ]);
        fillMissingBets.call(t);
        this.delayedInvoke('finish',1000);
        return;
      }
    };
    return worker;
  })(this);
  console.log('I SAD OPET');
  doTimeout();
}
//Helper function for filling missing bets to default bet
function fillMissingBets(){
  var ps = this.ctx.playingPlayers;
  ifor(var i=0; i<ps.length; i++){
    var activeHand = ps[i].player._activeHandString();
    var bet = this.ctx.data.element(['players',ps[i].seat,'bet']).value();
    var balance = this.ctx.data.element(['players',ps[i].seat,'balance']).value();
    if (!bet){
      this.ctx.data.commit('make_default_bet',[
        ['set',['players',ps[i].seat,'bet'],[parseInt(balance/10),undefined,this.ctx.self.key]]
      ]);
    }
  }
  return;
}
BettingState.prototype.nextState = function(){
  return new ChoosingDealerState(this.ctx);
}

BettingState.prototype.makeBet = function(amount,statuscb,username,realmname){
  var data = this.ctx.data;
  var ps = (this.ctx.playingPlayers?this.ctx.playingPlayers:this.playingPlayers());
  var pf;
  for(var i=0;i<ps.length;i++){
    if(ps[i].player._not_empty()===username){
      pf=ps[i];
    }
  }
  if(!pf){
    statuscb('NO_PLAYER');
    return;
  }
  console.log('---*---',activeHand);
  var bet = data.element(['players',pf.seat,'bet']).value();
  if (bet){
    console.log('You already placed your bet');
    return statuscb('INVALID_BET');
  }
  var balance = data.element(['players',pf.seat,'balance']).value();
  var betCount = data.element(['betCount']).value();
  if(amount<=0 || amount>balance){
    return statuscb('INVALID_BET');
  }
  data.commit('remove_old_bet',[
    ['remove',['players',pf.seat,'bet']]
  ]);
  data.commit('make_new_bet',[
    ['set',['players',pf.seat,'bet'],[amount,undefined,this.ctx.self.key]],
    ['set',['betCount'],[betCount+1]],
    ['set',['players',pf.seat,'balance'],[balance-amount,undefined,this.ctx.self.key]]
  ]);
  return statuscb('OK');
}

function ChoosingDealerState(ctx){
  MJState.call(this,ctx);
}

ChoosingDealerState.prototype = new MJState();

ChoosingDealerState.prototype.go = function (){
  console.log('It is time to chose dealer');
  console.log('Roll the dice, div by 4 and chose the dealer.');
  this.data.commit('init_dealer_seat',[
    ['set',['dealerSeat'],[0]],
    ['set',['nextPlayerSeat'],[0]]
  ]);
  console.log('Players can take a 5sec break before next round...');
  this.delayedInvoke('finish',5000);
}

ChoosingDealerState.prototype.nextState = function(){
    return new DealingState(this.ctx);
  }
}

function DealingState(ctx){
  MJState.call(this,ctx);
}

DealingState.prototype = new MJState();

DealingState.prototype.go = function(){
  var data = this.ctx.data;
  var roundCount = data.element(['roundCount']);
  if (roundCount == 0){
    console.log('GAME STARTED!');
  }
  if (roundCount < 16){
    console.log('Round',roundCount+1,'is about to start!');
    console.log('Players can take a 5sec break before next round...');
    console.log('Time to deal tiles to all players...');
    var ps = this.ctx.playingPlayers;
    this.ctx.handId = this.ctx.cbs.newHandId();
    this.ctx.deck = new tiles.Deck();
    var dealerSeat = this.ctx.data.element(['dealerSeat']).value();
    if ( (roundCount == 4) || (roundCount == 8) || (roundCount == 12) ){
        dealerSeat = (dealerSeat + 1) % MAHJONGKAPACITY;
        this.ctx.data.commit('set_new_dealerSeat',[
          ['set',['dealerSeat'],[dealerSeat]],
          ['set',['nextPlayerSeat'],[dealerSeat]]
        ]);
    }
    var i;
    for (var j=0; j<13; j++){
      for (i=0; i<ps.length; i++){
        ps[(dealerSeat + i)%MAHJONGKAPACITY].player._addCard();
      }
    }
    //Add 14th card to dealer
    ps[(dealerSeat + i)%MAHJONGKAPACITY].player._addCard();
    this.dealingStateHint = 'playing';
  }else{
    console.log('You played 16 rounds. Game ENDS!');
    this.dealingStateHint = 'end';
  }
  this.delayedInvoke('finish',3000);
}

DealingState.prototype.nextState = function(){
  switch (this.dealingStateHint){
    case 'playing':
      return new PlayingState(this.ctx);
    case 'end':
      return new GameEndingState(this.ctx);
  }
}

function PlayingState(ctx){
  MJState.call(this,ctx);
}

PlayingState.prototype = new MJState();

PlayingState.prototype.go = function(){
  console.log('Dealer starts by discarding a tile');
  console.log('If we run out of tiles state ends');
  console.log('Else we continue this round...'); 
  var ps = this.ctx.playingPlayers,
    _this = this;
  var index=_this.ctx.data.element(['nextPlayerSeat']).value();
  var player = ps[index];
  this.ctx.data.commit('set_nextPlayerSeat',[
    ['set',['nextPlayerSeat'],[(index+1)%MAHJONGKAPACITY]]
  ]);
  function next(op){
    switch(op){
      case 'steal':
        _this.playingStateHint = 'steal';
        break;
      case 'end':
        _this.playingStateHint = 'end';
        break;
    }
    _this.delayedInvoke('finish',10000);
  }
  player.player._ask(next);
}

PlayingState.prototype.nextState = function(){
  switch (this.playingStateHint){
    case 'steal':
      return new StealingState(this.ctx);
    case 'end':
      return new SumState(this.ctx);
  }
}

function StealingState(ctx){
  MJState.call(this,ctx);
}

StealingState.prototype = new MJState();

StealingState.prototype.go = function(){
  console.log('Players got 5seconds to steal the discard!');
  this.ctx.data.commit('set_stealing_flag',[
    ['set',['stealingFlag'],[1]]
  ]);
  this.delayedInvoke('checkAndFinish',5000);
}

StealingState.prototype.checkAndFinish = function(){
  this.ctx.data.commit('remove_stealing_flag',[
    ['remove',['stealingFlag']]
  ]);
  this.finish();
}

StealingState.prototype.steal = function(statuscb,username,realmname){
  var data = this.ctx.data;
  var ps = this.ctx.playingPlayers;
  var pf;
  for(var i=0;i<ps.length;i++){
    if(ps[i].player._not_empty()===username){
      pf=ps[i];
    }
  }
  if(!pf){
    statuscb('NO_PLAYER');
    return;
  }
  var discard = data.element(['discard']).value();
  var hand = pf.player._get_hand();
  var newHand = hand.push(discard);
  var dealerSeat = data.element(['dealerSeat']).value();
  if (isMahjong(newHand)){
    checkStealPriority.call(this,3,pf.seat);
    return statuscb('OK');
  }
  if (isPung(newHand)){
    checkStealPriority.call(this,2,pf.seat);
    return statuscb('OK');
  }
  if ( isChow(newHand) && ((dealerSeat+1)%MAHJONGKAPACITY == pf.seat) ){
    checkStealPriority.call(this,1,pf.seat);
    return statuscb('OK');
  }
}

function checkStealPriority(priority,seat){
  var data = this.ctx.data;
  var highestStealPriorty = data.element(['highestStealPriorty']);
  if (!!highestStealPriorty){
    var hspValue = highestStealPriorty.value();
    if (priority > hspValue){
      data.commit('new_highestStealPriorty',[
        ['set',['highestStealPriorty'],[priority]],
        ['set',['nextPlayerSeat'],[seat]]
      ]);
    }
  }else{
    data.commit('new_highestStealPriorty',[
      ['set',['highestStealPriorty'],[priority]],
      ['set',['nextPlayerSeat'],[seat]]
    ]);
  }
}

StealingState.prototype.nextState = function(){
  return new PlayingState(this.ctx);
}

function SumState(ctx){
  MJState.call(this,ctx);
}

SumState.prototype = new MJState();

SumState.prototype.go = function(){
  console.log('Depends on room type : Chinese, Japanese, American or other mahjong');
  console.log('Traverse all players and count the points won or lost!');
  console.log('You need to inform players who won and who lost');
  this.delayedInvoke('finish',3000);
}

SumState.prototype.nextState = function(){
  return new DealingState(this.ctx);
}

function GameEndingState(ctx){
  MJState.call(this,ctx);
}

GameEndingState.prototype = new MJState();

GameEndingState.prototype.go = function(){
  console.log('Resting all data for players at the end of the game!');
  var ps = this.ctx.playingPlayers;
  var actions = [];
  for(var i=0 ; i<ps.length ; i++){
    var seat = ps[i].seat;
    var player = this.ctx.data.element(['players',seat]);
    actions.push(['set',['players',seat,'bet'],[0]]);
  }
  this.ctx.data.commit('finish_game',actions);
  console.log('Waiting 10sec to who wants to play again');
  this.ctx.data.commit('betting_timeout',[
    ['set',['endingTimeout'],[10]],
    ['set',['stayCount'],[0]]
  ]);
  var doTimeout = (function(_t){
    console.log('Ending Timeout!');
    console.log('Stay or leave!');
    var t=_t,data=t.ctx.data,key=t.ctx.key;
    var worker = function(){
      var stayCount = data.element(['stayCount']).value();
      if(stayCount == MAHJONGKAPACITY){
        chooseNextState.call(t);
        data.commit('remove_timeout',[
          ['remove',['endingTimeout']],
          ['remove',['stayCount']]
        ]);
        t.delayedInvoke('finish',1000);
        return;
      }
      var toval = data.element(['endingTimeout']).value();
      console.log('TIME LEFT---',toval);
      if(toval){
        console.log('KUCAM DALJE');
        data.commit('timeout_changes',[
          ['set',['endingTimeout'],[toval-1]]
        ]);
        Timeout.set(worker,1000);
      }else{
        chooseNextState.call(t);
        data.commit('remove_timeout',[
          ['remove',['endingTimeout']],
          ['remove',['stayCount']]
        ]);
        t.delayedInvoke('finish',1000);
        return;
      }
    };
    return worker;
  })(this);
  console.log('I SAD OPET');
  doTimeout();
}

function chooseNextState(){
  var playercount = this.ctx.data.element(['playercount']).value();
  if(playercount == MAHJONGKAPACITY){
    this.gameEndingStatehint = 'betting';
  }else{
    if(playercount == 0){
      this.gameEndingStatehint = 'idle';
    }else{
      this.gameEndingStatehint = 'wait';
    }
  }
}

GameEndingState.prototype.iWantOut = function(statuscb,username,realmname){
  WaitingState.prototype.iWantOut.call(this);
  var stayCountObj = this.ctx.data.element(['stayCount']);
  if (!!stayCountObj){
    var stayCount = stayCountObj.value();
    this.ctx.data.commit('increase_stayCount',[
      ['set',['stayCount'],[stayCount+1]]
    ]);
  }
};

GameEndingState.prototype.iWantToStay = function(statuscb,username,realmname){
  var stayCountObj = this.ctx.data.element(['stayCount']);
  if (!!stayCountObj){
    var stayCount = stayCountObj.value();
    this.ctx.data.commit('increase_stayCount',[
      ['set',['stayCount'],[stayCount+1]]
    ]);
  }
}

GameEndingState.prototype.nextState = function(){
  switch (this.gameEndingStatehint){
    case 'idle':
      return new IdleState(this.ctx);
    case 'wait':
      return new WaitingState(this.ctx);
    case 'betting':
      return new BettingState(this.ctx);
  }
}


module.exports = IdleState;
